# Silver Layer: The Enrichment Engine (`silver_data_generator.py`)

This script is the central feature engineering hub of the Strategy Finder pipeline. Its purpose is to take the raw "possibilities" generated by the Bronze Layer and enrich them with deep market context, transforming a simple list of trades into an intelligent, feature-rich dataset ready for machine learning.

## üéØ Purpose in the Pipeline

If the Bronze Layer answers "what trades _could have_ won?", the Silver Layer answers "**under what market conditions** did they win?". It can operate in two modes:

1.  **Full Mode (Default):** Performs two major stages:
    *   **Market Feature Generation:** Creates a comprehensive "fingerprint" of the market for every moment in time by calculating over 200 technical indicators, candlestick patterns, and contextual features from the raw price data.
    *   **Trade Enrichment:** Merges this market context with every single trade from the Bronze Layer, calculating a powerful set of **relational positioning features**.

2.  **Features-Only Mode:** Performs only the **Market Feature Generation** stage. This is a utility mode used by other scripts, like the `diamond_data_prepper`, that only need the market context without the trade enrichment.

---

## ‚ú® Key Features

- **Comprehensive Feature Engineering:** Generates a vast suite of features, including:
  - Standard indicators (SMAs, EMAs, MACD, RSI, ADX).
  - Volatility measures (Bollinger Bands, ATR).
  - All candlestick patterns from the `talib` library.
  - Fractal-based Support and Resistance levels.
  - Time-based features (Forex session, hour, day of the week).
- **High-Performance Enrichment:** Uses a parallel producer-consumer architecture to process multi-gigabyte Bronze datasets efficiently across all available CPU cores.
- **Optimized Data I/O:** Reads Bronze data from the fast Parquet format and writes its own output in chunked Parquet files, minimizing disk I/O bottlenecks.
- **Memory-Safe Architecture:** By processing data in streamed batches and using a sophisticated NumPy-based lookup mechanism, the script avoids memory-intensive DataFrame merges and can run on standard hardware.
- **Intelligent Relational Features:** Goes beyond simple indicator values by calculating _where_ a trade's entry, SL, and TP are relative to market levels. For example, it calculates `sl_dist_to_SMA_50_bps` (how far the stop loss was from the 50-period SMA in basis points).

---

## ‚öôÔ∏è How It Works: The Logic

The script processes one instrument at a time.

**Stage 1: Market Feature Generation (Always Runs)**

1.  **Load Raw Data:** The raw OHLC `.csv` file is loaded and validated.
2.  **Calculate Feature Batches:** Features are calculated in logical groups (standard indicators, patterns, S/R, etc.) for code clarity.
3.  **Concatenate & Save:** All feature groups are combined into a single master DataFrame. An `INDICATOR_WARMUP_PERIOD` is applied (the first N rows are dropped) to ensure all indicators have stable starting values.
4.  **Save:** This master market context file is saved as a single `.csv` in `/silver_data/features/`.

**Stage 2: Parallel Trade Enrichment (Full Mode Only)**

1.  **Create Lookup Structures:** The script pre-computes the market features into highly efficient lookup structures: a NumPy array for the raw data and a Pandas Series that maps every timestamp to its corresponding row index.
2.  **Producer (Main Process):** The main process opens the large Bronze `.parquet` file and uses `pyarrow.iter_batches` to read the trade data in efficient, memory-friendly chunks.
3.  **Consumers (Worker Processes):** Multiple worker processes run in parallel, each pulling a chunk from a shared queue. They use the fast lookup structures to enrich the trades with relational features and save the output to chunked Parquet files.

---

## üõ†Ô∏è Dependencies

This script requires several specialized libraries. Install them via pip:

```bash
pip install pyarrow ta
```

The `talib` library requires a separate, platform-specific installation. Please refer to its official documentation.

---

## üîß Configuration

Key parameters can be tuned directly in the global configuration section at the top of the script:

- `MAX_CPU_USAGE`: Sets the number of CPU cores to use for the parallel enrichment stage.
- `PARQUET_BATCH_SIZE`: The suggested number of rows to read from the Bronze Parquet file in each batch.
- `INDICATOR_WARMUP_PERIOD`: The number of initial candles to discard from the features dataset to ensure indicator stability.
- **Indicator Parameters:** All periods, standard deviations, etc., for SMAs, MACD, BBands, etc., can be easily modified.

---

## üöÄ Usage

Execute the script from the root directory of the project.

### Full Mode

**1. Interactive Mode (Recommended):**

The script will scan for new `.parquet` files in `/bronze_data` and present a menu for full processing.

```bash
python scripts/silver_data_generator.py
```

**2. Targeted Mode:**

To process a specific file from the `/bronze_data` directory, pass its name as an argument.

```bash
python scripts/silver_data_generator.py EURUSD15.parquet
```

### Features-Only Mode

**3. Features-Only Mode (For Automation):**

This mode is designed to be called by other scripts. It skips the interactive menu and the trade enrichment stage, generating only the market features CSV file for a given raw data file.

```bash
# The target file must be a raw data file (e.g., from /raw_data/)
python scripts/silver_data_generator.py EURUSD15.csv --features-only```

---

## üìÑ Output

This script produces up to two distinct sets of outputs in the `/silver_data/` directory:

**1. Market Features (`/features/{instrument}.csv`):** (Generated in all modes)
A single, large CSV file per instrument containing the full market context for every candlestick.

**2. Enriched Trades (`/chunked_outcomes/{instrument}/chunk_*.parquet`):** (Generated in Full Mode only)
A directory for each instrument containing multiple Parquet files. Each file is a chunk of the original Bronze data, now enriched with dozens of new relational positioning columns.
```